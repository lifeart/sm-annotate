import { describe, it, expect } from 'vitest';
import {
  exportToOpenRV,
  hexToRGBA,
  type OpenRVExportOptions,
} from '../src/exporters/openrv';
import type { FrameAnnotationV1 } from '../src/core';
import type { ICurve } from '../src/plugins/curve';
import type { ILine } from '../src/plugins/line';
import type { IArrow } from '../src/plugins/arrow';
import type { IRectangle } from '../src/plugins/rectangle';
import type { ICircle } from '../src/plugins/circle';
import type { IText } from '../src/plugins/text';
import type { IEraser } from '../src/plugins/eraser';

describe('OpenRV Exporter', () => {
  describe('hexToRGBA', () => {
    it('should convert 6-digit hex to RGBA', () => {
      const result = hexToRGBA('#ff0000');
      expect(result[0]).toBeCloseTo(1, 5);
      expect(result[1]).toBeCloseTo(0, 5);
      expect(result[2]).toBeCloseTo(0, 5);
      expect(result[3]).toBeCloseTo(1, 5);
    });

    it('should convert 3-digit hex to RGBA', () => {
      const result = hexToRGBA('#f00');
      expect(result[0]).toBeCloseTo(1, 5);
      expect(result[1]).toBeCloseTo(0, 5);
      expect(result[2]).toBeCloseTo(0, 5);
      expect(result[3]).toBeCloseTo(1, 5);
    });

    it('should convert hex without # prefix', () => {
      const result = hexToRGBA('00ff00');
      expect(result[0]).toBeCloseTo(0, 5);
      expect(result[1]).toBeCloseTo(1, 5);
      expect(result[2]).toBeCloseTo(0, 5);
      expect(result[3]).toBeCloseTo(1, 5);
    });

    it('should convert 8-digit hex with alpha', () => {
      const result = hexToRGBA('#ff000080');
      expect(result[0]).toBeCloseTo(1, 5);
      expect(result[1]).toBeCloseTo(0, 5);
      expect(result[2]).toBeCloseTo(0, 5);
      expect(result[3]).toBeCloseTo(0.502, 2); // 128/255
    });

    it('should apply opacity parameter', () => {
      const result = hexToRGBA('#ffffff', 0.5);
      expect(result[0]).toBeCloseTo(1, 5);
      expect(result[1]).toBeCloseTo(1, 5);
      expect(result[2]).toBeCloseTo(1, 5);
      expect(result[3]).toBeCloseTo(0.5, 5);
    });

    it('should convert blue color', () => {
      const result = hexToRGBA('#0000ff');
      expect(result[0]).toBeCloseTo(0, 5);
      expect(result[1]).toBeCloseTo(0, 5);
      expect(result[2]).toBeCloseTo(1, 5);
    });
  });

  describe('exportToOpenRV', () => {
    const defaultOptions: OpenRVExportOptions = {
      mediaPath: '/path/to/video.mp4',
      width: 1920,
      height: 1080,
    };

    it('should generate valid GTO header', () => {
      const result = exportToOpenRV([], defaultOptions);

      expect(result).toContain('GTOa (4)');
      expect(result).toContain('# Generated by sm-annotate OpenRV exporter');
      expect(result).toContain('RVSession : RVSession (4)');
    });

    it('should include media path in source', () => {
      const result = exportToOpenRV([], defaultOptions);

      expect(result).toContain('sourceGroup000000_source : RVFileSource (1)');
      expect(result).toContain('string movie = "/path/to/video.mp4"');
      expect(result).toContain('int width = 1920');
      expect(result).toContain('int height = 1080');
    });

    it('should export curve shape as pen component', () => {
      const curveShape: ICurve = {
        type: 'curve',
        points: [
          { x: 0.1, y: 0.2 },
          { x: 0.3, y: 0.4 },
          { x: 0.5, y: 0.6 },
        ],
        strokeStyle: '#ff0000',
        fillStyle: '#ffffff',
        lineWidth: 3,
        opacity: 0.8,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [curveShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('sourceGroup000000_paint : RVPaint (3)');
      expect(result).toContain('"pen:0:1:User"');
      expect(result).toContain('float[4] color');
      expect(result).toContain('float width = [');
      expect(result).toContain('float[2] points');
    });

    it('should export line shape as pen component', () => {
      const lineShape: ILine = {
        type: 'line',
        x1: 0.1,
        y1: 0.2,
        x2: 0.8,
        y2: 0.9,
        strokeStyle: '#00ff00',
        fillStyle: '#ffffff',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 5, fps: 30, version: 1, shapes: [lineShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"pen:0:5:User"');
    });

    it('should export arrow as multiple pen components', () => {
      const arrowShape: IArrow = {
        type: 'arrow',
        x1: 0.1,
        y1: 0.1,
        x2: 0.9,
        y2: 0.9,
        strokeStyle: '#0000ff',
        fillStyle: '#ffffff',
        lineWidth: 4,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 10, fps: 25, version: 1, shapes: [arrowShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Arrow creates 3 components: main line + 2 arrowhead lines
      expect(result).toContain('"pen:0:10:User"');
      expect(result).toContain('"pen:1:10:User"');
      expect(result).toContain('"pen:2:10:User"');
    });

    it('should export rectangle as closed path pen component', () => {
      const rectShape: IRectangle = {
        type: 'rectangle',
        x: 0.2,
        y: 0.3,
        width: 0.4,
        height: 0.2,
        strokeStyle: '#ffff00',
        fillStyle: '#ffffff',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 3, fps: 25, version: 1, shapes: [rectShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"pen:0:3:User"');
      expect(result).toContain('float[2] points');
    });

    it('should export circle as polygon pen component', () => {
      const circleShape: ICircle = {
        type: 'circle',
        x: 0.5,
        y: 0.5,
        radius: 0.1,
        strokeStyle: '#ff00ff',
        fillStyle: '#ffffff',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 7, fps: 25, version: 1, shapes: [circleShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"pen:0:7:User"');
      // Circle is approximated with many points
      expect(result).toContain('float[2] points');
    });

    it('should export text as text component', () => {
      const textShape: IText = {
        type: 'text',
        x: 0.3,
        y: 0.4,
        text: 'Hello World',
        strokeStyle: '#000000',
        fillStyle: '#ffffff',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 15, fps: 25, version: 1, shapes: [textShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"text:0:15:User"');
      expect(result).toContain('float[2] position');
      expect(result).toContain('string text = "Hello World"');
    });

    it('should handle text with special characters', () => {
      const textShape: IText = {
        type: 'text',
        x: 0.1,
        y: 0.1,
        text: 'Line1\nLine2',
        strokeStyle: '#000000',
        fillStyle: '#ffffff',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [textShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"text:0:1:User"');
      expect(result).toContain('\\n'); // Escaped newline
    });

    it('should skip non-visual shapes', () => {
      const frames: FrameAnnotationV1[] = [
        {
          frame: 1,
          fps: 25,
          version: 1,
          shapes: [
            { type: 'eraser', x: 0, y: 0, width: 0.1, height: 0.1, strokeStyle: '#000', fillStyle: '#000', lineWidth: 1 },
            { type: 'move', strokeStyle: '#000', fillStyle: '#000', lineWidth: 1 },
          ] as any[],
        },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Should not contain RVPaint node since no visual shapes
      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should export multiple frames', () => {
      const shape1: ICurve = {
        type: 'curve',
        points: [{ x: 0.1, y: 0.1 }, { x: 0.2, y: 0.2 }],
        strokeStyle: '#ff0000',
        fillStyle: '#fff',
        lineWidth: 2,
      };

      const shape2: ILine = {
        type: 'line',
        x1: 0.3,
        y1: 0.3,
        x2: 0.4,
        y2: 0.4,
        strokeStyle: '#00ff00',
        fillStyle: '#fff',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape1] },
        { frame: 10, fps: 25, version: 1, shapes: [shape2] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"pen:0:1:User"');
      expect(result).toContain('"pen:1:10:User"');
      expect(result).toContain('"frame:1"');
      expect(result).toContain('"frame:10"');
    });

    it('should generate correct nextId', () => {
      const arrowShape: IArrow = {
        type: 'arrow',
        x1: 0.1,
        y1: 0.1,
        x2: 0.5,
        y2: 0.5,
        strokeStyle: '#000',
        fillStyle: '#fff',
        lineWidth: 2,
      };

      const lineShape: ILine = {
        type: 'line',
        x1: 0.6,
        y1: 0.6,
        x2: 0.9,
        y2: 0.9,
        strokeStyle: '#000',
        fillStyle: '#fff',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [arrowShape, lineShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Arrow = 3 components (id 0, 1, 2), line = 1 component (id 3)
      // nextId should be 4
      expect(result).toContain('int nextId = 4');
    });

    it('should use custom session name', () => {
      const options: OpenRVExportOptions = {
        ...defaultOptions,
        sessionName: 'my-custom-session',
      };

      const result = exportToOpenRV([], options);

      expect(result).toContain('string name = "my-custom-session"');
    });

    it('should generate frame order components', () => {
      const shape1: ILine = {
        type: 'line',
        x1: 0.1,
        y1: 0.1,
        x2: 0.2,
        y2: 0.2,
        strokeStyle: '#000',
        fillStyle: '#fff',
        lineWidth: 1,
      };

      const shape2: ILine = {
        type: 'line',
        x1: 0.3,
        y1: 0.3,
        x2: 0.4,
        y2: 0.4,
        strokeStyle: '#000',
        fillStyle: '#fff',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 5, fps: 25, version: 1, shapes: [shape1, shape2] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"frame:5"');
      expect(result).toContain('string order');
      expect(result).toContain('"pen:0:5:User"');
      expect(result).toContain('"pen:1:5:User"');
    });

    it('should handle empty frames array', () => {
      const result = exportToOpenRV([], defaultOptions);

      expect(result).toContain('GTOa (4)');
      expect(result).toContain('RVSession : RVSession (4)');
      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should convert to OpenRV NDC coordinates correctly', () => {
      const shape: ILine = {
        type: 'line',
        x1: 0.5,
        y1: 0.5,
        x2: 1.0,
        y2: 1.0,
        strokeStyle: '#000',
        fillStyle: '#fff',
        lineWidth: 2,
      };

      const options: OpenRVExportOptions = {
        mediaPath: '/test.mp4',
        width: 1000,
        height: 500,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, options);

      // aspectRatio = 1000/500 = 2
      // sm-annotate (0.5, 0.5) -> OpenRV (0, 0): x = (0.5*2-1)*2 = 0, y = 1-0.5*2 = 0
      // sm-annotate (1.0, 1.0) -> OpenRV (2, -1): x = (1.0*2-1)*2 = 2, y = 1-1.0*2 = -1
      expect(result).toContain('points = [ [ 0 0 ] [ 2 -1 ] ]');
    });

    it('should handle rgb() color format', () => {
      const shape: ICurve = {
        type: 'curve',
        points: [{ x: 0.1, y: 0.1 }, { x: 0.2, y: 0.2 }],
        strokeStyle: 'rgb(255, 128, 64)',
        fillStyle: 'rgb(255, 128, 64)',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // rgb(255, 128, 64) -> [1.0, 0.502, 0.251, 1.0]
      expect(result).toContain('"pen:0:1:User"');
    });

    it('should handle rgba() color format', () => {
      const shape: ICurve = {
        type: 'curve',
        points: [{ x: 0.1, y: 0.1 }, { x: 0.2, y: 0.2 }],
        strokeStyle: 'rgba(255, 0, 0, 0.5)',
        fillStyle: 'rgba(255, 0, 0, 0.5)',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"pen:0:1:User"');
      // Alpha should be 0.5
      expect(result).toContain('0.5');
    });

    it('should handle rectangle with negative dimensions', () => {
      const shape: IRectangle = {
        type: 'rectangle',
        x: 0.5,
        y: 0.5,
        width: -0.2,  // negative width
        height: -0.1, // negative height
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"pen:0:1:User"');
      // Rectangle should still be exported with 5 points (closed path)
      expect(result).toContain('float[2] points');
    });

    it('should generate correct number of points for circle', () => {
      const shape: ICircle = {
        type: 'circle',
        x: 0.5,
        y: 0.5,
        radius: 0.1,
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Circle is approximated with 32 segments + 1 closing point = 33 points
      // The points line will contain the format: [ [ x y ] [ x y ] ... ]
      expect(result).toContain('"pen:0:1:User"');
      expect(result).toContain('float[2] points');
      // Check that we have multiple point pairs (circle approximation)
      // The width array should have 33 entries for 33 points
      const widthMatch = result.match(/float width = \[([^\]]+)\]/);
      expect(widthMatch).not.toBeNull();
      const widthValues = widthMatch![1].trim().split(/\s+/).filter(s => s.length > 0);
      expect(widthValues.length).toBe(33); // 33 points for the circle
    });

    it('should handle text with quotes', () => {
      const shape: IText = {
        type: 'text',
        x: 0.1,
        y: 0.1,
        text: 'He said "Hello"',
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"text:0:1:User"');
      expect(result).toContain('\\"'); // Escaped quotes
    });

    it('should skip eraser shapes', () => {
      const shape: IEraser = {
        type: 'eraser',
        x: 0.1,
        y: 0.1,
        width: 0.2,
        height: 0.2,
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // No paint node should be created
      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should skip selection shapes', () => {
      const shape = {
        type: 'selection',
        x: 0.1,
        y: 0.1,
        width: 0.2,
        height: 0.2,
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape as any] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should skip compare shapes', () => {
      const shape = {
        type: 'compare',
        x: 0.5,
        disabled: false,
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape as any] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should skip audio-peaks shapes', () => {
      const shape = {
        type: 'audio-peaks',
        x: 0.5,
        y: 0.5,
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape as any] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should skip image shapes', () => {
      const shape = {
        type: 'image',
        x: 0.1,
        y: 0.1,
        width: 0.5,
        height: 0.5,
        image: {} as HTMLImageElement,
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape as any] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should apply rotation to curve points', () => {
      // A horizontal line from (0.4, 0.5) to (0.6, 0.5) rotated 90 degrees
      // around center (0.5, 0.5) becomes vertical line from (0.5, 0.4) to (0.5, 0.6)
      const shape: ICurve = {
        type: 'curve',
        points: [{ x: 0.4, y: 0.5 }, { x: 0.6, y: 0.5 }],
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
        rotation: Math.PI / 2, // 90 degrees
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // After 90 degree rotation around center (0.5, 0.5):
      // (0.4, 0.5) -> (0.5, 0.4), then to OpenRV: (0, 0.2)
      // (0.6, 0.5) -> (0.5, 0.6), then to OpenRV: (0, -0.2)
      // For aspectRatio=1: openrv_x = sm_x*2-1, openrv_y = 1-sm_y*2
      expect(result).toContain('"pen:0:1:User"');
      // Check that output has proper OpenRV NDC coordinates
      expect(result).toContain('[ [ 0 0.2 ] [ 0 -0.2 ] ]');
    });

    it('should apply rotation to rectangle points', () => {
      // Rectangle at (0.4, 0.4) with width 0.2, height 0.2, rotated 45 degrees
      const shape: IRectangle = {
        type: 'rectangle',
        x: 0.4,
        y: 0.4,
        width: 0.2,
        height: 0.2,
        strokeStyle: '#00ff00',
        fillStyle: '#00ff00',
        lineWidth: 2,
        rotation: Math.PI / 4, // 45 degrees
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // Should export rotated rectangle as pen stroke
      expect(result).toContain('"pen:0:1:User"');
      // The center should still be around (500, 500) in a 1000x1000 canvas
      // but corner points will be rotated
    });

    it('should apply rotation with custom rotation center', () => {
      // Line from (0.3, 0.5) to (0.5, 0.5) rotated 90 degrees around (0.3, 0.5)
      // The start point stays at (0.3, 0.5), end point rotates to (0.3, 0.7)
      const shape: ILine = {
        type: 'line',
        x1: 0.3,
        y1: 0.5,
        x2: 0.5,
        y2: 0.5,
        strokeStyle: '#0000ff',
        fillStyle: '#0000ff',
        lineWidth: 2,
        rotation: Math.PI / 2, // 90 degrees
        rotationCenterX: 0.3,
        rotationCenterY: 0.5,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // After rotation around (0.3, 0.5):
      // (0.3, 0.5) stays at (0.3, 0.5), then to OpenRV: (-0.4, 0)
      // (0.5, 0.5) rotates to (0.3, 0.7), then to OpenRV: (-0.4, -0.4)
      // For aspectRatio=1: openrv_x = sm_x*2-1, openrv_y = 1-sm_y*2
      expect(result).toContain('"pen:0:1:User"');
      // Check that output has proper OpenRV NDC coordinates
      expect(result).toContain('-0.4');
    });

    it('should apply rotation to arrow components', () => {
      // Arrow rotated 180 degrees - all 3 components should be rotated
      const shape: IArrow = {
        type: 'arrow',
        x1: 0.3,
        y1: 0.5,
        x2: 0.7,
        y2: 0.5,
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
        rotation: Math.PI, // 180 degrees
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // Arrow has 3 pen components (main line + 2 arrowhead lines)
      expect(result).toContain('"pen:0:1:User"');
      expect(result).toContain('"pen:1:1:User"');
      expect(result).toContain('"pen:2:1:User"');
      // After 180 degree rotation around center (0.5, 0.5):
      // (0.3, 0.5) -> (0.7, 0.5), (0.7, 0.5) -> (0.3, 0.5)
      // Convert to OpenRV NDC (aspectRatio=1): x = sm_x*2-1, y = 1-sm_y*2
      // (0.7, 0.5) -> (0.4, 0), (0.3, 0.5) -> (-0.4, 0)
      expect(result).toContain('0.4');
      expect(result).toContain('-0.4');
    });

    it('should apply rotation to circle points', () => {
      // Circle rotation doesn't visually change a perfect circle,
      // but points should still be rotated
      const shape: ICircle = {
        type: 'circle',
        x: 0.5,
        y: 0.5,
        radius: 0.1,
        strokeStyle: '#00ff00',
        fillStyle: '#00ff00',
        lineWidth: 2,
        rotation: Math.PI / 2, // 90 degrees
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // Circle should be exported with 33 points as a pen component
      expect(result).toContain('"pen:0:1:User"');
      // The first point without rotation would be at sm-annotate (0.6, 0.5) - x + radius at angle 0
      // After 90 degree rotation around center (0.5, 0.5), it becomes (0.5, 0.4)
      // Convert to OpenRV NDC: (0.5, 0.4) -> (0, 0.2)
      expect(result).toContain('0.2');
    });

    it('should not affect shapes without rotation', () => {
      const shape: ICurve = {
        type: 'curve',
        points: [{ x: 0.1, y: 0.2 }, { x: 0.3, y: 0.4 }],
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
        // No rotation property
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // Points should be converted to OpenRV NDC
      // sm-annotate (0.1, 0.2) -> OpenRV (-0.8, 0.6)
      // sm-annotate (0.3, 0.4) -> OpenRV (-0.4, 0.2)
      expect(result).toContain('"pen:0:1:User"');
      expect(result).toContain('[ [ -0.8 0.6 ] [ -0.4 0.2 ] ]');
    });

    it('should export multiple shapes on same frame', () => {
      const curve: ICurve = {
        type: 'curve',
        points: [{ x: 0.1, y: 0.1 }, { x: 0.2, y: 0.2 }],
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
      };

      const text: IText = {
        type: 'text',
        x: 0.5,
        y: 0.5,
        text: 'Label',
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [curve, text] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"pen:0:1:User"');
      expect(result).toContain('"text:1:1:User"');
      expect(result).toContain('int nextId = 2');
    });

    it('should handle curve with single point', () => {
      const shape: ICurve = {
        type: 'curve',
        points: [{ x: 0.5, y: 0.5 }],
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Single point curve should still be exported
      expect(result).toContain('"pen:0:1:User"');
    });

    it('should preserve shape order in frame order component', () => {
      const shape1: ILine = {
        type: 'line',
        x1: 0.1, y1: 0.1, x2: 0.2, y2: 0.2,
        strokeStyle: '#ff0000', fillStyle: '#ff0000', lineWidth: 1,
      };
      const shape2: ILine = {
        type: 'line',
        x1: 0.3, y1: 0.3, x2: 0.4, y2: 0.4,
        strokeStyle: '#00ff00', fillStyle: '#00ff00', lineWidth: 1,
      };
      const shape3: ILine = {
        type: 'line',
        x1: 0.5, y1: 0.5, x2: 0.6, y2: 0.6,
        strokeStyle: '#0000ff', fillStyle: '#0000ff', lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape1, shape2, shape3] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Order should match input order
      const orderMatch = result.match(/string order = \[([^\]]+)\]/);
      expect(orderMatch).not.toBeNull();
      expect(orderMatch![1]).toContain('"pen:0:1:User"');
      expect(orderMatch![1]).toContain('"pen:1:1:User"');
      expect(orderMatch![1]).toContain('"pen:2:1:User"');
    });

    it('should handle very large frame numbers', () => {
      const shape: ILine = {
        type: 'line',
        x1: 0.1, y1: 0.1, x2: 0.2, y2: 0.2,
        strokeStyle: '#000', fillStyle: '#000', lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 100000, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('"pen:0:100000:User"');
      expect(result).toContain('"frame:100000"');
    });
  });

  describe('coordinate conversion for various aspect ratios', () => {
    it('should convert to correct OpenRV NDC for ultrawide (21:9) aspect ratio', () => {
      // Ultrawide 21:9 -> aspectRatio = 2560/1080 ≈ 2.37
      const width = 2560;
      const height = 1080;
      const aspectRatio = width / height;

      const shape: ILine = {
        type: 'line',
        // sm-annotate corners: top-left (0,0) and bottom-right (1,1)
        x1: 0,
        y1: 0,
        x2: 1,
        y2: 1,
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 24, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, {
        mediaPath: '/test.mp4',
        width,
        height,
      });

      // sm-annotate (0, 0) -> OpenRV (-aspectRatio, 1)
      // sm-annotate (1, 1) -> OpenRV (aspectRatio, -1)
      // For aspectRatio ≈ 2.37: -2.37..2.37 range
      expect(result).toContain(`-${aspectRatio.toFixed(6)}`);
      expect(result).toContain(`${aspectRatio.toFixed(6)}`);
    });

    it('should convert to correct OpenRV NDC for portrait (9:16) aspect ratio', () => {
      // Portrait 9:16 -> aspectRatio = 1080/1920 = 0.5625
      const width = 1080;
      const height = 1920;

      const shape: ILine = {
        type: 'line',
        // sm-annotate center (0.5, 0.5) should map to OpenRV (0, 0)
        x1: 0.5,
        y1: 0.5,
        x2: 1.0,
        y2: 1.0,
        strokeStyle: '#00ff00',
        fillStyle: '#00ff00',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 30, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, {
        mediaPath: '/test.mp4',
        width,
        height,
      });

      // sm-annotate (0.5, 0.5) -> OpenRV (0, 0)
      expect(result).toContain('[ [ 0 0 ]');
      // sm-annotate (1.0, 1.0) -> OpenRV (aspectRatio, -1) = (0.5625, -1)
      expect(result).toContain('0.5625');
      expect(result).toContain('-1 ]');
    });

    it('should convert to correct OpenRV NDC for square (1:1) aspect ratio', () => {
      const width = 1000;
      const height = 1000;

      const shape: ILine = {
        type: 'line',
        // sm-annotate top-left (0, 0) and bottom-right (1, 1)
        x1: 0,
        y1: 0,
        x2: 1,
        y2: 1,
        strokeStyle: '#0000ff',
        fillStyle: '#0000ff',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, {
        mediaPath: '/test.mp4',
        width,
        height,
      });

      // sm-annotate (0, 0) -> OpenRV (-1, 1)
      // sm-annotate (1, 1) -> OpenRV (1, -1)
      expect(result).toContain('[ [ -1 1 ] [ 1 -1 ] ]');
    });

    it('should convert text position correctly for various aspect ratios', () => {
      const width = 1920;
      const height = 1080;

      const shape: IText = {
        type: 'text',
        // sm-annotate top-left (0, 0) should map to OpenRV (-aspectRatio, 1)
        x: 0,
        y: 0,
        text: 'Top Left',
        strokeStyle: '#ffffff',
        fillStyle: '#ffffff',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 24, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, {
        mediaPath: '/test.mp4',
        width,
        height,
      });

      // sm-annotate (0, 0) -> OpenRV (-aspectRatio, 1) where aspectRatio = 1920/1080 ≈ 1.777...
      // The position should contain negative aspect ratio and 1
      expect(result).toContain('position = [ [ -1.77777');
      expect(result).toContain('1 ] ]');
    });

    it('should normalize lineWidth correctly for different heights', () => {
      // LineWidth should be normalized by dividing by height
      const width = 1920;
      const height = 1080;

      const shape: ICurve = {
        type: 'curve',
        points: [{ x: 0.5, y: 0.5 }, { x: 0.6, y: 0.6 }],
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 5.4, // 5.4 / 1080 = 0.005
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 24, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, {
        mediaPath: '/test.mp4',
        width,
        height,
      });

      // Normalized width = 5.4 / 1080 = 0.005
      expect(result).toContain('0.005');
    });
  });
});
