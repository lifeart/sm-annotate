import { describe, it, expect } from 'vitest';
import {
  exportToOpenRV,
  hexToRGBA,
  type OpenRVExportOptions,
} from '../src/exporters/openrv';
import type { FrameAnnotationV1 } from '../src/core';
import type { ICurve } from '../src/plugins/curve';
import type { ILine } from '../src/plugins/line';
import type { IArrow } from '../src/plugins/arrow';
import type { IRectangle } from '../src/plugins/rectangle';
import type { ICircle } from '../src/plugins/circle';
import type { IText } from '../src/plugins/text';
import type { IEraser } from '../src/plugins/eraser';

describe('OpenRV Exporter', () => {
  describe('hexToRGBA', () => {
    it('should convert 6-digit hex to RGBA', () => {
      const result = hexToRGBA('#ff0000');
      expect(result[0]).toBeCloseTo(1, 5);
      expect(result[1]).toBeCloseTo(0, 5);
      expect(result[2]).toBeCloseTo(0, 5);
      expect(result[3]).toBeCloseTo(1, 5);
    });

    it('should convert 3-digit hex to RGBA', () => {
      const result = hexToRGBA('#f00');
      expect(result[0]).toBeCloseTo(1, 5);
      expect(result[1]).toBeCloseTo(0, 5);
      expect(result[2]).toBeCloseTo(0, 5);
      expect(result[3]).toBeCloseTo(1, 5);
    });

    it('should convert hex without # prefix', () => {
      const result = hexToRGBA('00ff00');
      expect(result[0]).toBeCloseTo(0, 5);
      expect(result[1]).toBeCloseTo(1, 5);
      expect(result[2]).toBeCloseTo(0, 5);
      expect(result[3]).toBeCloseTo(1, 5);
    });

    it('should convert 8-digit hex with alpha', () => {
      const result = hexToRGBA('#ff000080');
      expect(result[0]).toBeCloseTo(1, 5);
      expect(result[1]).toBeCloseTo(0, 5);
      expect(result[2]).toBeCloseTo(0, 5);
      expect(result[3]).toBeCloseTo(0.502, 2); // 128/255
    });

    it('should apply opacity parameter', () => {
      const result = hexToRGBA('#ffffff', 0.5);
      expect(result[0]).toBeCloseTo(1, 5);
      expect(result[1]).toBeCloseTo(1, 5);
      expect(result[2]).toBeCloseTo(1, 5);
      expect(result[3]).toBeCloseTo(0.5, 5);
    });

    it('should convert blue color', () => {
      const result = hexToRGBA('#0000ff');
      expect(result[0]).toBeCloseTo(0, 5);
      expect(result[1]).toBeCloseTo(0, 5);
      expect(result[2]).toBeCloseTo(1, 5);
    });
  });

  describe('exportToOpenRV', () => {
    const defaultOptions: OpenRVExportOptions = {
      mediaPath: '/path/to/video.mp4',
      width: 1920,
      height: 1080,
    };

    it('should generate valid GTO header', () => {
      const result = exportToOpenRV([], defaultOptions);

      expect(result).toContain('GTOa (4)');
      expect(result).toContain('# Generated by sm-annotate OpenRV exporter');
      expect(result).toContain('RVSession : RVSession (4)');
    });

    it('should include media path in source', () => {
      const result = exportToOpenRV([], defaultOptions);

      expect(result).toContain('sourceGroup000000_source : RVFileSource (1)');
      expect(result).toContain('string movie = "/path/to/video.mp4"');
      expect(result).toContain('int width = 1920');
      expect(result).toContain('int height = 1080');
    });

    it('should export curve shape as pen component', () => {
      const curveShape: ICurve = {
        type: 'curve',
        points: [
          { x: 0.1, y: 0.2 },
          { x: 0.3, y: 0.4 },
          { x: 0.5, y: 0.6 },
        ],
        strokeStyle: '#ff0000',
        fillStyle: '#ffffff',
        lineWidth: 3,
        opacity: 0.8,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [curveShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('sourceGroup000000_paint : RVPaint (3)');
      expect(result).toContain('pen:0:1:user');
      expect(result).toContain('float[4] color');
      expect(result).toContain('float width = 3');
      expect(result).toContain('float[2] points');
      expect(result).toContain('int frame = 1');
    });

    it('should export line shape as pen component', () => {
      const lineShape: ILine = {
        type: 'line',
        x1: 0.1,
        y1: 0.2,
        x2: 0.8,
        y2: 0.9,
        strokeStyle: '#00ff00',
        fillStyle: '#ffffff',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 5, fps: 30, version: 1, shapes: [lineShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('pen:0:5:user');
      expect(result).toContain('int frame = 5');
    });

    it('should export arrow as multiple pen components', () => {
      const arrowShape: IArrow = {
        type: 'arrow',
        x1: 0.1,
        y1: 0.1,
        x2: 0.9,
        y2: 0.9,
        strokeStyle: '#0000ff',
        fillStyle: '#ffffff',
        lineWidth: 4,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 10, fps: 25, version: 1, shapes: [arrowShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Arrow creates 3 components: main line + 2 arrowhead lines
      expect(result).toContain('pen:0:10:user');
      expect(result).toContain('pen:1:10:user');
      expect(result).toContain('pen:2:10:user');
    });

    it('should export rectangle as closed path pen component', () => {
      const rectShape: IRectangle = {
        type: 'rectangle',
        x: 0.2,
        y: 0.3,
        width: 0.4,
        height: 0.2,
        strokeStyle: '#ffff00',
        fillStyle: '#ffffff',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 3, fps: 25, version: 1, shapes: [rectShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('pen:0:3:user');
      expect(result).toContain('float[2] points');
    });

    it('should export circle as polygon pen component', () => {
      const circleShape: ICircle = {
        type: 'circle',
        x: 0.5,
        y: 0.5,
        radius: 0.1,
        strokeStyle: '#ff00ff',
        fillStyle: '#ffffff',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 7, fps: 25, version: 1, shapes: [circleShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('pen:0:7:user');
      // Circle is approximated with many points
      expect(result).toContain('float[2] points');
    });

    it('should export text as text component', () => {
      const textShape: IText = {
        type: 'text',
        x: 0.3,
        y: 0.4,
        text: 'Hello World',
        strokeStyle: '#000000',
        fillStyle: '#ffffff',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 15, fps: 25, version: 1, shapes: [textShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('text:0:15:user');
      expect(result).toContain('float[2] position');
      expect(result).toContain('string text = "Hello World"');
    });

    it('should handle text with special characters', () => {
      const textShape: IText = {
        type: 'text',
        x: 0.1,
        y: 0.1,
        text: 'Line1\nLine2',
        strokeStyle: '#000000',
        fillStyle: '#ffffff',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [textShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('text:0:1:user');
      expect(result).toContain('\\n'); // Escaped newline
    });

    it('should skip non-visual shapes', () => {
      const frames: FrameAnnotationV1[] = [
        {
          frame: 1,
          fps: 25,
          version: 1,
          shapes: [
            { type: 'eraser', x: 0, y: 0, width: 0.1, height: 0.1, strokeStyle: '#000', fillStyle: '#000', lineWidth: 1 },
            { type: 'move', strokeStyle: '#000', fillStyle: '#000', lineWidth: 1 },
          ] as any[],
        },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Should not contain RVPaint node since no visual shapes
      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should export multiple frames', () => {
      const shape1: ICurve = {
        type: 'curve',
        points: [{ x: 0.1, y: 0.1 }, { x: 0.2, y: 0.2 }],
        strokeStyle: '#ff0000',
        fillStyle: '#fff',
        lineWidth: 2,
      };

      const shape2: ILine = {
        type: 'line',
        x1: 0.3,
        y1: 0.3,
        x2: 0.4,
        y2: 0.4,
        strokeStyle: '#00ff00',
        fillStyle: '#fff',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape1] },
        { frame: 10, fps: 25, version: 1, shapes: [shape2] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('pen:0:1:user');
      expect(result).toContain('pen:1:10:user');
      expect(result).toContain('frame:1');
      expect(result).toContain('frame:10');
    });

    it('should generate correct nextId', () => {
      const arrowShape: IArrow = {
        type: 'arrow',
        x1: 0.1,
        y1: 0.1,
        x2: 0.5,
        y2: 0.5,
        strokeStyle: '#000',
        fillStyle: '#fff',
        lineWidth: 2,
      };

      const lineShape: ILine = {
        type: 'line',
        x1: 0.6,
        y1: 0.6,
        x2: 0.9,
        y2: 0.9,
        strokeStyle: '#000',
        fillStyle: '#fff',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [arrowShape, lineShape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Arrow = 3 components (id 0, 1, 2), line = 1 component (id 3)
      // nextId should be 4
      expect(result).toContain('int nextId = 4');
    });

    it('should use custom session name', () => {
      const options: OpenRVExportOptions = {
        ...defaultOptions,
        sessionName: 'my-custom-session',
      };

      const result = exportToOpenRV([], options);

      expect(result).toContain('string name = "my-custom-session"');
    });

    it('should generate frame order components', () => {
      const shape1: ILine = {
        type: 'line',
        x1: 0.1,
        y1: 0.1,
        x2: 0.2,
        y2: 0.2,
        strokeStyle: '#000',
        fillStyle: '#fff',
        lineWidth: 1,
      };

      const shape2: ILine = {
        type: 'line',
        x1: 0.3,
        y1: 0.3,
        x2: 0.4,
        y2: 0.4,
        strokeStyle: '#000',
        fillStyle: '#fff',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 5, fps: 25, version: 1, shapes: [shape1, shape2] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('frame:5');
      expect(result).toContain('string order');
      expect(result).toContain('"pen:0:5:user"');
      expect(result).toContain('"pen:1:5:user"');
    });

    it('should handle empty frames array', () => {
      const result = exportToOpenRV([], defaultOptions);

      expect(result).toContain('GTOa (4)');
      expect(result).toContain('RVSession : RVSession (4)');
      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should denormalize coordinates correctly', () => {
      const shape: ILine = {
        type: 'line',
        x1: 0.5,
        y1: 0.5,
        x2: 1.0,
        y2: 1.0,
        strokeStyle: '#000',
        fillStyle: '#fff',
        lineWidth: 2,
      };

      const options: OpenRVExportOptions = {
        mediaPath: '/test.mp4',
        width: 1000,
        height: 500,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, options);

      // x1=0.5 * 1000 = 500, y1=0.5 * 500 = 250
      // x2=1.0 * 1000 = 1000, y2=1.0 * 500 = 500
      expect(result).toContain('500.000000');
      expect(result).toContain('250.000000');
      expect(result).toContain('1000.000000');
    });

    it('should handle rgb() color format', () => {
      const shape: ICurve = {
        type: 'curve',
        points: [{ x: 0.1, y: 0.1 }, { x: 0.2, y: 0.2 }],
        strokeStyle: 'rgb(255, 128, 64)',
        fillStyle: 'rgb(255, 128, 64)',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // rgb(255, 128, 64) -> [1.0, 0.502, 0.251, 1.0]
      expect(result).toContain('1.000000');
      expect(result).toContain('pen:0:1:user');
    });

    it('should handle rgba() color format', () => {
      const shape: ICurve = {
        type: 'curve',
        points: [{ x: 0.1, y: 0.1 }, { x: 0.2, y: 0.2 }],
        strokeStyle: 'rgba(255, 0, 0, 0.5)',
        fillStyle: 'rgba(255, 0, 0, 0.5)',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('pen:0:1:user');
      // Alpha should be 0.5
      expect(result).toContain('0.500000');
    });

    it('should handle rectangle with negative dimensions', () => {
      const shape: IRectangle = {
        type: 'rectangle',
        x: 0.5,
        y: 0.5,
        width: -0.2,  // negative width
        height: -0.1, // negative height
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('pen:0:1:user');
      // Rectangle should still be exported with 5 points (closed path)
      expect(result).toContain('float[2] points');
    });

    it('should generate correct number of points for circle', () => {
      const shape: ICircle = {
        type: 'circle',
        x: 0.5,
        y: 0.5,
        radius: 0.1,
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Circle is approximated with 32 segments + 1 closing point = 33 points
      // Each point is 2 floats (x, y), so 33 * 2 = 66 values
      const pointsMatch = result.match(/float\[2\] points = \[([^\]]+)\]/);
      expect(pointsMatch).not.toBeNull();
      const pointsStr = pointsMatch![1];
      const pointValues = pointsStr.trim().split(/\s+/);
      expect(pointValues.length).toBe(66); // 33 points * 2 coordinates
    });

    it('should handle text with quotes', () => {
      const shape: IText = {
        type: 'text',
        x: 0.1,
        y: 0.1,
        text: 'He said "Hello"',
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('text:0:1:user');
      expect(result).toContain('\\"'); // Escaped quotes
    });

    it('should skip eraser shapes', () => {
      const shape: IEraser = {
        type: 'eraser',
        x: 0.1,
        y: 0.1,
        width: 0.2,
        height: 0.2,
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // No paint node should be created
      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should skip selection shapes', () => {
      const shape = {
        type: 'selection',
        x: 0.1,
        y: 0.1,
        width: 0.2,
        height: 0.2,
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape as any] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should skip compare shapes', () => {
      const shape = {
        type: 'compare',
        x: 0.5,
        disabled: false,
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape as any] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should skip audio-peaks shapes', () => {
      const shape = {
        type: 'audio-peaks',
        x: 0.5,
        y: 0.5,
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape as any] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should skip image shapes', () => {
      const shape = {
        type: 'image',
        x: 0.1,
        y: 0.1,
        width: 0.5,
        height: 0.5,
        image: {} as HTMLImageElement,
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape as any] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).not.toContain('sourceGroup000000_paint');
    });

    it('should apply rotation to curve points', () => {
      // A horizontal line from (0.4, 0.5) to (0.6, 0.5) rotated 90 degrees
      // around center (0.5, 0.5) becomes vertical line from (0.5, 0.4) to (0.5, 0.6)
      const shape: ICurve = {
        type: 'curve',
        points: [{ x: 0.4, y: 0.5 }, { x: 0.6, y: 0.5 }],
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
        rotation: Math.PI / 2, // 90 degrees
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // After 90 degree rotation around center (500, 500):
      // (400, 500) -> (500, 400)
      // (600, 500) -> (500, 600)
      expect(result).toContain('pen:0:1:user');
      expect(result).toMatch(/points = \[.*500\.0.*400\.0.*500\.0.*600\.0.*\]/);
    });

    it('should apply rotation to rectangle points', () => {
      // Rectangle at (0.4, 0.4) with width 0.2, height 0.2, rotated 45 degrees
      const shape: IRectangle = {
        type: 'rectangle',
        x: 0.4,
        y: 0.4,
        width: 0.2,
        height: 0.2,
        strokeStyle: '#00ff00',
        fillStyle: '#00ff00',
        lineWidth: 2,
        rotation: Math.PI / 4, // 45 degrees
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // Should export rotated rectangle as pen stroke
      expect(result).toContain('pen:0:1:user');
      // The center should still be around (500, 500) in a 1000x1000 canvas
      // but corner points will be rotated
    });

    it('should apply rotation with custom rotation center', () => {
      // Line from (0.3, 0.5) to (0.5, 0.5) rotated 90 degrees around (0.3, 0.5)
      // The start point stays at (0.3, 0.5), end point rotates to (0.3, 0.7)
      const shape: ILine = {
        type: 'line',
        x1: 0.3,
        y1: 0.5,
        x2: 0.5,
        y2: 0.5,
        strokeStyle: '#0000ff',
        fillStyle: '#0000ff',
        lineWidth: 2,
        rotation: Math.PI / 2, // 90 degrees
        rotationCenterX: 0.3,
        rotationCenterY: 0.5,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // After rotation around (300, 500):
      // (300, 500) stays at (300, 500)
      // (500, 500) rotates to (300, 700)
      expect(result).toContain('pen:0:1:user');
      expect(result).toMatch(/points = \[.*300\.0.*500\.0.*300\.0.*700\.0.*\]/);
    });

    it('should apply rotation to arrow components', () => {
      // Arrow rotated 180 degrees - all 3 components should be rotated
      const shape: IArrow = {
        type: 'arrow',
        x1: 0.3,
        y1: 0.5,
        x2: 0.7,
        y2: 0.5,
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
        rotation: Math.PI, // 180 degrees
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // Arrow has 3 pen components (main line + 2 arrowhead lines)
      expect(result).toContain('pen:0:1:user');
      expect(result).toContain('pen:1:1:user');
      expect(result).toContain('pen:2:1:user');
      // After 180 degree rotation around center (500, 500):
      // (300, 500) -> (700, 500), (700, 500) -> (300, 500)
      expect(result).toMatch(/pen:0:1:user[\s\S]*?points = \[.*700\.0.*500\.0.*300\.0.*500\.0.*\]/);
    });

    it('should apply rotation to circle points', () => {
      // Circle rotation doesn't visually change a perfect circle,
      // but points should still be rotated
      const shape: ICircle = {
        type: 'circle',
        x: 0.5,
        y: 0.5,
        radius: 0.1,
        strokeStyle: '#00ff00',
        fillStyle: '#00ff00',
        lineWidth: 2,
        rotation: Math.PI / 2, // 90 degrees
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // Circle should be exported with 33 points
      expect(result).toContain('pen:0:1:user');
      // The first point without rotation would be at (600, 500) - x + radius at angle 0
      // After 90 degree rotation around center (500, 500), it becomes (500, 600)
      expect(result).toMatch(/points = \[.*500\.0+\s+600\.0/);
    });

    it('should not affect shapes without rotation', () => {
      const shape: ICurve = {
        type: 'curve',
        points: [{ x: 0.1, y: 0.2 }, { x: 0.3, y: 0.4 }],
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
        // No rotation property
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, { ...defaultOptions, width: 1000, height: 1000 });

      // Points should be unchanged (just denormalized)
      expect(result).toContain('pen:0:1:user');
      expect(result).toMatch(/points = \[.*100\.0+\s+200\.0+\s+300\.0+\s+400\.0.*\]/);
    });

    it('should export multiple shapes on same frame', () => {
      const curve: ICurve = {
        type: 'curve',
        points: [{ x: 0.1, y: 0.1 }, { x: 0.2, y: 0.2 }],
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
      };

      const text: IText = {
        type: 'text',
        x: 0.5,
        y: 0.5,
        text: 'Label',
        strokeStyle: '#000',
        fillStyle: '#000',
        lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [curve, text] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('pen:0:1:user');
      expect(result).toContain('text:1:1:user');
      expect(result).toContain('int nextId = 2');
    });

    it('should handle curve with single point', () => {
      const shape: ICurve = {
        type: 'curve',
        points: [{ x: 0.5, y: 0.5 }],
        strokeStyle: '#ff0000',
        fillStyle: '#ff0000',
        lineWidth: 2,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Single point curve should still be exported
      expect(result).toContain('pen:0:1:user');
    });

    it('should preserve shape order in frame order component', () => {
      const shape1: ILine = {
        type: 'line',
        x1: 0.1, y1: 0.1, x2: 0.2, y2: 0.2,
        strokeStyle: '#ff0000', fillStyle: '#ff0000', lineWidth: 1,
      };
      const shape2: ILine = {
        type: 'line',
        x1: 0.3, y1: 0.3, x2: 0.4, y2: 0.4,
        strokeStyle: '#00ff00', fillStyle: '#00ff00', lineWidth: 1,
      };
      const shape3: ILine = {
        type: 'line',
        x1: 0.5, y1: 0.5, x2: 0.6, y2: 0.6,
        strokeStyle: '#0000ff', fillStyle: '#0000ff', lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 1, fps: 25, version: 1, shapes: [shape1, shape2, shape3] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      // Order should match input order
      const orderMatch = result.match(/string order = \[([^\]]+)\]/);
      expect(orderMatch).not.toBeNull();
      expect(orderMatch![1]).toContain('"pen:0:1:user"');
      expect(orderMatch![1]).toContain('"pen:1:1:user"');
      expect(orderMatch![1]).toContain('"pen:2:1:user"');
    });

    it('should handle very large frame numbers', () => {
      const shape: ILine = {
        type: 'line',
        x1: 0.1, y1: 0.1, x2: 0.2, y2: 0.2,
        strokeStyle: '#000', fillStyle: '#000', lineWidth: 1,
      };

      const frames: FrameAnnotationV1[] = [
        { frame: 100000, fps: 25, version: 1, shapes: [shape] },
      ];

      const result = exportToOpenRV(frames, defaultOptions);

      expect(result).toContain('pen:0:100000:user');
      expect(result).toContain('int frame = 100000');
    });
  });
});
